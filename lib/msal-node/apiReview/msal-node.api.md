## API Report File for "@azure/msal-node"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AccessTokenCache } from '@azure/msal-common/node';
import { AccessTokenEntity } from '@azure/msal-common/node';
import { AccountCache } from '@azure/msal-common/node';
import { AccountEntity } from '@azure/msal-common/node';
import { AccountInfo } from '@azure/msal-common/node';
import { ApplicationTelemetry } from '@azure/msal-common/node';
import { AppMetadataCache } from '@azure/msal-common/node';
import { AppMetadataEntity } from '@azure/msal-common/node';
import { AppTokenProviderParameters } from '@azure/msal-common/node';
import { AppTokenProviderResult } from '@azure/msal-common/node';
import { AuthenticationResult } from '@azure/msal-common/node';
import { AuthError } from '@azure/msal-common/node';
import { AuthErrorCodes } from '@azure/msal-common/node';
import { AuthErrorMessage } from '@azure/msal-common/node';
import { Authority } from '@azure/msal-common/node';
import { AuthorityMetadataEntity } from '@azure/msal-common/node';
import { AuthorizationCodePayload } from '@azure/msal-common/node';
import { AzureCloudInstance } from '@azure/msal-common/node';
import { AzureCloudOptions } from '@azure/msal-common/node';
import { AzureRegionConfiguration } from '@azure/msal-common/node';
import { BaseAuthRequest } from '@azure/msal-common/node';
import { BaseClient } from '@azure/msal-common/node';
import { CacheManager } from '@azure/msal-common/node';
import { CacheOutcome } from '@azure/msal-common/node';
import { ClientAssertionCallback } from '@azure/msal-common/node';
import { ClientAuthError } from '@azure/msal-common/node';
import { ClientAuthErrorCodes } from '@azure/msal-common/node';
import { ClientAuthErrorMessage } from '@azure/msal-common/node';
import { ClientConfiguration } from '@azure/msal-common/node';
import { ClientConfigurationError } from '@azure/msal-common/node';
import { ClientConfigurationErrorCodes } from '@azure/msal-common/node';
import { ClientConfigurationErrorMessage } from '@azure/msal-common/node';
import { CommonAuthorizationCodeRequest } from '@azure/msal-common/node';
import { CommonAuthorizationUrlRequest } from '@azure/msal-common/node';
import { CommonClientCredentialRequest } from '@azure/msal-common/node';
import { CommonDeviceCodeRequest } from '@azure/msal-common/node';
import { CommonOnBehalfOfRequest } from '@azure/msal-common/node';
import { CommonRefreshTokenRequest } from '@azure/msal-common/node';
import { CommonSilentFlowRequest } from '@azure/msal-common/node';
import { CommonUsernamePasswordRequest } from '@azure/msal-common/node';
import { DeviceCodeResponse } from '@azure/msal-common/node';
import http from 'http';
import https from 'https';
import { IAppTokenProvider } from '@azure/msal-common/node';
import { ICachePlugin } from '@azure/msal-common/node';
import { ICrypto } from '@azure/msal-common/node';
import { IdTokenCache } from '@azure/msal-common/node';
import { IdTokenClaims } from '@azure/msal-common/node';
import { IdTokenEntity } from '@azure/msal-common/node';
import { INativeBrokerPlugin } from '@azure/msal-common/node';
import { INetworkModule } from '@azure/msal-common/node';
import { InteractionRequiredAuthError } from '@azure/msal-common/node';
import { InteractionRequiredAuthErrorCodes } from '@azure/msal-common/node';
import { InteractionRequiredAuthErrorMessage } from '@azure/msal-common/node';
import { ISerializableTokenCache } from '@azure/msal-common/node';
import { Logger } from '@azure/msal-common/node';
import { LoggerOptions } from '@azure/msal-common/node';
import { LogLevel } from '@azure/msal-common/node';
import { NetworkRequestOptions } from '@azure/msal-common/node';
import { NetworkResponse } from '@azure/msal-common/node';
import { PkceCodes } from '@azure/msal-common/node';
import { PromptValue } from '@azure/msal-common/node';
import { ProtocolMode } from '@azure/msal-common/node';
import { RefreshTokenCache } from '@azure/msal-common/node';
import { RefreshTokenEntity } from '@azure/msal-common/node';
import { ResponseMode } from '@azure/msal-common/node';
import { ServerAuthorizationCodeResponse } from '@azure/msal-common/node';
import { ServerError } from '@azure/msal-common/node';
import { ServerTelemetryEntity } from '@azure/msal-common/node';
import { ServerTelemetryManager } from '@azure/msal-common/node';
import { StaticAuthorityOptions } from '@azure/msal-common/node';
import { ThrottlingEntity } from '@azure/msal-common/node';
import { TokenCacheContext } from '@azure/msal-common/node';
import { TokenKeys } from '@azure/msal-common/node';
import { ValidCacheType } from '@azure/msal-common/node';
import { ValidCredentialType } from '@azure/msal-common/node';

export { AccountInfo }

export { AppTokenProviderParameters }

export { AppTokenProviderResult }

export { AuthenticationResult }

export { AuthError }

export { AuthErrorCodes }

export { AuthErrorMessage }

export { AuthorizationCodePayload }

// @public
export type AuthorizationCodeRequest = Partial<Omit<CommonAuthorizationCodeRequest, "scopes" | "redirectUri" | "code" | "authenticationScheme" | "resourceRequestMethod" | "resourceRequestUri" | "requestedClaimsHash" | "storeInCache">> & {
    scopes: Array<string>;
    redirectUri: string;
    code: string;
    state?: string;
};

// @public
export type AuthorizationUrlRequest = Partial<Omit<CommonAuthorizationUrlRequest, "scopes" | "redirectUri" | "resourceRequestMethod" | "resourceRequestUri" | "authenticationScheme" | "requestedClaimsHash" | "storeInCache">> & {
    scopes: Array<string>;
    redirectUri: string;
};

export { AzureCloudInstance }

export { AzureCloudOptions }

// @public
export type BrokerOptions = {
    nativeBrokerPlugin?: INativeBrokerPlugin;
};

// @public
export type CacheKVStore = Record<string, ValidCacheType>;

// @public
export type CacheOptions = {
    cachePlugin?: ICachePlugin;
    claimsBasedCachingEnabled?: boolean;
};

// @public
export abstract class ClientApplication {
    protected constructor(configuration: Configuration);
    acquireTokenByCode(request: AuthorizationCodeRequest, authCodePayLoad?: AuthorizationCodePayload): Promise<AuthenticationResult>;
    acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult | null>;
    acquireTokenByUsernamePassword(request: UsernamePasswordRequest): Promise<AuthenticationResult | null>;
    acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult>;
    protected buildOauthClientConfiguration(authority: string, requestCorrelationId: string, redirectUri: string, serverTelemetryManager?: ServerTelemetryManager, azureRegionConfiguration?: AzureRegionConfiguration, azureCloudOptions?: AzureCloudOptions): Promise<ClientConfiguration>;
    clearCache(): void;
    protected clientAssertion: ClientAssertion;
    protected clientSecret: string;
    // Warning: (ae-forgotten-export) The symbol "NodeConfiguration" needs to be exported by the entry point index.d.ts
    protected config: NodeConfiguration;
    // (undocumented)
    protected readonly cryptoProvider: CryptoProvider;
    // (undocumented)
    protected developerProvidedClientAssertion: string | ClientAssertionCallback;
    getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string>;
    getLogger(): Logger;
    getTokenCache(): TokenCache;
    protected initializeBaseRequest(authRequest: Partial<BaseAuthRequest>): Promise<BaseAuthRequest>;
    protected initializeServerTelemetryManager(apiId: number, correlationId: string, forceRefresh?: boolean): ServerTelemetryManager;
    protected logger: Logger;
    setLogger(logger: Logger): void;
    protected storage: NodeStorage;
    protected validateState(state: string, cachedState: string): void;
}

// @public
export class ClientAssertion {
    static fromAssertion(assertion: string): ClientAssertion;
    // @deprecated (undocumented)
    static fromCertificate(thumbprint: string, privateKey: string, publicCertificate?: string): ClientAssertion;
    static fromCertificateWithSha256Thumbprint(thumbprint: string, privateKey: string, publicCertificate?: string): ClientAssertion;
    getJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string;
    static parseCertificate(publicCertificate: string): Array<string>;
}

export { ClientAssertionCallback }

export { ClientAuthError }

export { ClientAuthErrorCodes }

export { ClientAuthErrorMessage }

export { ClientConfigurationError }

export { ClientConfigurationErrorCodes }

export { ClientConfigurationErrorMessage }

// @public
export class ClientCredentialClient extends BaseClient {
    constructor(configuration: ClientConfiguration, appTokenProvider?: IAppTokenProvider);
    acquireToken(request: CommonClientCredentialRequest): Promise<AuthenticationResult | null>;
    getCachedAuthenticationResult(request: CommonClientCredentialRequest, config: ClientConfiguration | ManagedIdentityConfiguration, cryptoUtils: ICrypto, authority: Authority, cacheManager: CacheManager, serverTelemetryManager?: ServerTelemetryManager | null): Promise<[AuthenticationResult | null, CacheOutcome]>;
}

// @public
export type ClientCredentialRequest = Partial<Omit<CommonClientCredentialRequest, "resourceRequestMethod" | "resourceRequestUri" | "requestedClaimsHash" | "clientAssertion" | "storeInCache">> & {
    clientAssertion?: string | ClientAssertionCallback;
};

// @public
export class ConfidentialClientApplication extends ClientApplication implements IConfidentialClientApplication {
    constructor(configuration: Configuration);
    acquireTokenByClientCredential(request: ClientCredentialRequest): Promise<AuthenticationResult | null>;
    acquireTokenOnBehalfOf(request: OnBehalfOfRequest): Promise<AuthenticationResult | null>;
    SetAppTokenProvider(provider: IAppTokenProvider): void;
}

// @public
export type Configuration = {
    auth: NodeAuthOptions;
    broker?: BrokerOptions;
    cache?: CacheOptions;
    system?: NodeSystemOptions;
    telemetry?: NodeTelemetryOptions;
};

// @public
export class CryptoProvider implements ICrypto {
    constructor();
    base64Decode(input: string): string;
    base64Encode(input: string): string;
    base64UrlEncode(): string;
    clearKeystore(): Promise<boolean>;
    createNewGuid(): string;
    encodeKid(): string;
    generatePkceCodes(): Promise<PkceCodes>;
    getPublicKeyThumbprint(): Promise<string>;
    hashString(plainText: string): Promise<string>;
    removeTokenBindingKey(): Promise<boolean>;
    signJwt(): Promise<string>;
}

// @internal
class Deserializer {
    static deserializeAccessTokens(accessTokens: Record<string, SerializedAccessTokenEntity>): AccessTokenCache;
    static deserializeAccounts(accounts: Record<string, SerializedAccountEntity>): AccountCache;
    static deserializeAllCache(jsonCache: JsonCache): InMemoryCache;
    static deserializeAppMetadata(appMetadata: Record<string, SerializedAppMetadataEntity>): AppMetadataCache;
    static deserializeIdTokens(idTokens: Record<string, SerializedIdTokenEntity>): IdTokenCache;
    static deserializeJSONBlob(jsonFile: string): JsonCache;
    static deserializeRefreshTokens(refreshTokens: Record<string, SerializedRefreshTokenEntity>): RefreshTokenCache;
}

// @public
export class DeviceCodeClient extends BaseClient {
    constructor(configuration: ClientConfiguration);
    acquireToken(request: CommonDeviceCodeRequest): Promise<AuthenticationResult | null>;
    createExtraQueryParameters(request: CommonDeviceCodeRequest): string;
}

// @public
export type DeviceCodeRequest = Partial<Omit<CommonDeviceCodeRequest, "scopes" | "deviceCodeCallback" | "resourceRequestMethod" | "resourceRequestUri" | "requestedClaimsHash" | "storeInCache">> & {
    scopes: Array<string>;
    deviceCodeCallback: (response: DeviceCodeResponse) => void;
};

// @public
export class DistributedCachePlugin implements ICachePlugin {
    constructor(client: ICacheClient, partitionManager: IPartitionManager);
    afterCacheAccess(cacheContext: TokenCacheContext): Promise<void>;
    beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void>;
}

export { IAppTokenProvider }

// @public
export interface ICacheClient {
    get(key: string): Promise<string>;
    set(key: string, value: string): Promise<string>;
}

export { ICachePlugin }

// @public
export interface IConfidentialClientApplication {
    acquireTokenByClientCredential(request: ClientCredentialRequest): Promise<AuthenticationResult | null>;
    acquireTokenByCode(request: AuthorizationCodeRequest): Promise<AuthenticationResult>;
    acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult | null>;
    acquireTokenByUsernamePassword(request: UsernamePasswordRequest): Promise<AuthenticationResult | null>;
    acquireTokenOnBehalfOf(request: OnBehalfOfRequest): Promise<AuthenticationResult | null>;
    acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult | null>;
    clearCache(): void;
    getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string>;
    getLogger(): Logger;
    getTokenCache(): TokenCache;
    SetAppTokenProvider(provider: IAppTokenProvider): void;
    setLogger(logger: Logger): void;
}

export { IdTokenClaims }

// @public
export interface ILoopbackClient {
    // (undocumented)
    closeServer(): void;
    // (undocumented)
    getRedirectUri(): string;
    // (undocumented)
    listenForAuthCode(successTemplate?: string, errorTemplate?: string): Promise<ServerAuthorizationCodeResponse>;
}

export { INativeBrokerPlugin }

export { INetworkModule }

// @public
export type InMemoryCache = {
    accounts: AccountCache;
    idTokens: IdTokenCache;
    accessTokens: AccessTokenCache;
    refreshTokens: RefreshTokenCache;
    appMetadata: AppMetadataCache;
};

export { InteractionRequiredAuthError }

export { InteractionRequiredAuthErrorCodes }

export { InteractionRequiredAuthErrorMessage }

// @public
export type InteractiveRequest = Partial<Omit<CommonAuthorizationUrlRequest, "scopes" | "redirectUri" | "requestedClaimsHash" | "storeInCache">> & {
    openBrowser: (url: string) => Promise<void>;
    scopes?: Array<string>;
    successTemplate?: string;
    errorTemplate?: string;
    windowHandle?: Buffer;
    loopbackClient?: ILoopbackClient;
};

declare namespace internals {
    export {
        Serializer,
        Deserializer
    }
}
export { internals }

// @public
export interface IPartitionManager {
    extractKey(accountEntity: AccountEntity): Promise<string>;
    getKey(): Promise<string>;
}

// @public
export interface IPublicClientApplication {
    acquireTokenByCode(request: AuthorizationCodeRequest): Promise<AuthenticationResult>;
    acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<AuthenticationResult | null>;
    acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult | null>;
    acquireTokenByUsernamePassword(request: UsernamePasswordRequest): Promise<AuthenticationResult | null>;
    acquireTokenInteractive(request: InteractiveRequest): Promise<AuthenticationResult>;
    acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult>;
    clearCache(): void;
    getAllAccounts(): Promise<AccountInfo[]>;
    getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string>;
    getLogger(): Logger;
    getTokenCache(): TokenCache;
    setLogger(logger: Logger): void;
    signOut(request: SignOutRequest): Promise<void>;
}

export { ISerializableTokenCache }

// @public
export interface ITokenCache {
    getAccountByHomeId(homeAccountId: string): Promise<AccountInfo | null>;
    getAccountByLocalId(localAccountId: string): Promise<AccountInfo | null>;
    getAllAccounts(): Promise<AccountInfo[]>;
    removeAccount(account: AccountInfo): Promise<void>;
}

// @public
export type JsonCache = {
    Account: Record<string, SerializedAccountEntity>;
    IdToken: Record<string, SerializedIdTokenEntity>;
    AccessToken: Record<string, SerializedAccessTokenEntity>;
    RefreshToken: Record<string, SerializedRefreshTokenEntity>;
    AppMetadata: Record<string, SerializedAppMetadataEntity>;
};

export { Logger }

export { LogLevel }

// @public
export class ManagedIdentityApplication {
    constructor(configuration?: ManagedIdentityConfiguration);
    acquireToken(managedIdentityRequestParams: ManagedIdentityRequestParams): Promise<AuthenticationResult>;
    getManagedIdentitySource(): ManagedIdentitySourceNames;
}

// @public (undocumented)
export type ManagedIdentityConfiguration = {
    managedIdentityIdParams?: ManagedIdentityIdParams;
    system?: NodeSystemOptions;
};

// @public (undocumented)
export type ManagedIdentityIdParams = {
    userAssignedClientId?: string;
    userAssignedResourceId?: string;
    userAssignedObjectId?: string;
};

// @public
export type ManagedIdentityRequestParams = {
    claims?: string;
    forceRefresh?: boolean;
    resource: string;
};

// @public
export const ManagedIdentitySourceNames: {
    readonly APP_SERVICE: "AppService";
    readonly AZURE_ARC: "AzureArc";
    readonly CLOUD_SHELL: "CloudShell";
    readonly DEFAULT_TO_IMDS: "DefaultToImds";
    readonly IMDS: "Imds";
    readonly SERVICE_FABRIC: "ServiceFabric";
};

// @public
export type ManagedIdentitySourceNames = (typeof ManagedIdentitySourceNames)[keyof typeof ManagedIdentitySourceNames];

export { NetworkRequestOptions }

export { NetworkResponse }

// @public
export type NodeAuthOptions = {
    clientId: string;
    authority?: string;
    clientSecret?: string;
    clientAssertion?: string | ClientAssertionCallback;
    clientCertificate?: {
        thumbprint?: string;
        thumbprintSha256?: string;
        privateKey: string;
        x5c?: string;
    };
    knownAuthorities?: Array<string>;
    cloudDiscoveryMetadata?: string;
    authorityMetadata?: string;
    clientCapabilities?: Array<string>;
    protocolMode?: ProtocolMode;
    azureCloudOptions?: AzureCloudOptions;
    skipAuthorityMetadataCache?: boolean;
};

// @public
export class NodeStorage extends CacheManager {
    constructor(logger: Logger, clientId: string, cryptoImpl: ICrypto, staticAuthorityOptions?: StaticAuthorityOptions);
    cacheToInMemoryCache(cache: CacheKVStore): InMemoryCache;
    clear(): void;
    containsKey(key: string): boolean;
    emitChange(): void;
    static generateInMemoryCache(cache: string): InMemoryCache;
    static generateJsonCache(inMemoryCache: InMemoryCache): JsonCache;
    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null;
    getAccount(accountKey: string): AccountEntity | null;
    // (undocumented)
    getAccountKeys(): string[];
    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;
    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;
    getAuthorityMetadataKeys(): Array<string>;
    getCache(): CacheKVStore;
    getCachedAccountEntity(accountKey: string): AccountEntity | null;
    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;
    getInMemoryCache(): InMemoryCache;
    getItem(key: string): ValidCacheType;
    getKeys(): string[];
    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null;
    getServerTelemetry(serverTelemetrykey: string): ServerTelemetryEntity | null;
    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null;
    // (undocumented)
    getTokenKeys(): TokenKeys;
    inMemoryCacheToCache(inMemoryCache: InMemoryCache): CacheKVStore;
    registerChangeEmitter(func: () => void): void;
    removeItem(key: string): boolean;
    removeOutdatedAccount(accountKey: string): void;
    setAccessTokenCredential(accessToken: AccessTokenEntity): void;
    setAccount(account: AccountEntity): void;
    setAppMetadata(appMetadata: AppMetadataEntity): void;
    setAuthorityMetadata(key: string, metadata: AuthorityMetadataEntity): void;
    setCache(cache: CacheKVStore): void;
    setIdTokenCredential(idToken: IdTokenEntity): void;
    setInMemoryCache(inMemoryCache: InMemoryCache): void;
    setItem(key: string, value: ValidCacheType): void;
    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;
    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void;
    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void;
    updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string;
}

// @public
export type NodeSystemOptions = {
    loggerOptions?: LoggerOptions;
    networkClient?: INetworkModule;
    proxyUrl?: string;
    customAgentOptions?: http.AgentOptions | https.AgentOptions;
    disableInternalRetries?: boolean;
};

// @public (undocumented)
export type NodeTelemetryOptions = {
    application?: ApplicationTelemetry;
};

// @public
export class OnBehalfOfClient extends BaseClient {
    constructor(configuration: ClientConfiguration);
    acquireToken(request: CommonOnBehalfOfRequest): Promise<AuthenticationResult | null>;
}

// @public
export type OnBehalfOfRequest = Partial<Omit<CommonOnBehalfOfRequest, "oboAssertion" | "scopes" | "resourceRequestMethod" | "resourceRequestUri" | "requestedClaimsHash" | "storeInCache">> & {
    oboAssertion: string;
    scopes: Array<string>;
};

export { PromptValue }

export { ProtocolMode }

// @public
export class PublicClientApplication extends ClientApplication implements IPublicClientApplication {
    constructor(configuration: Configuration);
    acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<AuthenticationResult | null>;
    acquireTokenInteractive(request: InteractiveRequest): Promise<AuthenticationResult>;
    acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult>;
    getAllAccounts(): Promise<AccountInfo[]>;
    signOut(request: SignOutRequest): Promise<void>;
}

// @public
export type RefreshTokenRequest = Partial<Omit<CommonRefreshTokenRequest, "scopes" | "refreshToken" | "authenticationScheme" | "resourceRequestMethod" | "resourceRequestUri" | "requestedClaimsHash" | "storeInCache">> & {
    scopes: Array<string>;
    refreshToken: string;
    forceCache?: boolean;
};

export { ResponseMode }

// @public
export type SerializedAccessTokenEntity = {
    home_account_id: string;
    environment: string;
    credential_type: string;
    client_id: string;
    secret: string;
    realm: string;
    target: string;
    cached_at: string;
    expires_on: string;
    extended_expires_on?: string;
    refresh_on?: string;
    key_id?: string;
    token_type?: string;
    requestedClaims?: string;
    requestedClaimsHash?: string;
    userAssertionHash?: string;
};

// @public
export type SerializedAccountEntity = {
    home_account_id: string;
    environment: string;
    realm: string;
    local_account_id: string;
    username: string;
    authority_type: string;
    name?: string;
    client_info?: string;
    last_modification_time?: string;
    last_modification_app?: string;
    tenantProfiles?: string[];
};

// @public
export type SerializedAppMetadataEntity = {
    client_id: string;
    environment: string;
    family_id?: string;
};

// @public
export type SerializedIdTokenEntity = {
    home_account_id: string;
    environment: string;
    credential_type: string;
    client_id: string;
    secret: string;
    realm: string;
};

// @public
export type SerializedRefreshTokenEntity = {
    home_account_id: string;
    environment: string;
    credential_type: string;
    client_id: string;
    secret: string;
    family_id?: string;
    target?: string;
    realm?: string;
};

// @internal
class Serializer {
    static serializeAccessTokens(atCache: AccessTokenCache): Record<string, SerializedAccessTokenEntity>;
    static serializeAccounts(accCache: AccountCache): Record<string, SerializedAccountEntity>;
    static serializeAllCache(inMemCache: InMemoryCache): JsonCache;
    static serializeAppMetadata(amdtCache: AppMetadataCache): Record<string, SerializedAppMetadataEntity>;
    static serializeIdTokens(idTCache: IdTokenCache): Record<string, SerializedIdTokenEntity>;
    static serializeJSONBlob(data: JsonCache): string;
    static serializeRefreshTokens(rtCache: RefreshTokenCache): Record<string, SerializedRefreshTokenEntity>;
}

export { ServerAuthorizationCodeResponse }

export { ServerError }

// @public (undocumented)
export type SignOutRequest = {
    account: AccountInfo;
    correlationId?: string;
};

// @public
export type SilentFlowRequest = Partial<Omit<CommonSilentFlowRequest, "account" | "scopes" | "requestedClaimsHash" | "storeInCache">> & {
    account: AccountInfo;
    scopes: Array<string>;
};

// @public
export class TokenCache implements ISerializableTokenCache, ITokenCache {
    constructor(storage: NodeStorage, logger: Logger, cachePlugin?: ICachePlugin);
    deserialize(cache: string): void;
    getAccountByHomeId(homeAccountId: string): Promise<AccountInfo | null>;
    getAccountByLocalId(localAccountId: string): Promise<AccountInfo | null>;
    getAllAccounts(): Promise<AccountInfo[]>;
    getKVStore(): CacheKVStore;
    hasChanged(): boolean;
    removeAccount(account: AccountInfo): Promise<void>;
    serialize(): string;
}

export { TokenCacheContext }

// @public
export class UsernamePasswordClient extends BaseClient {
    constructor(configuration: ClientConfiguration);
    acquireToken(request: CommonUsernamePasswordRequest): Promise<AuthenticationResult | null>;
}

// @public
export type UsernamePasswordRequest = Partial<Omit<CommonUsernamePasswordRequest, "scopes" | "resourceRequestMethod" | "resourceRequestUri" | "username" | "password" | "requestedClaimsHash" | "storeInCache">> & {
    scopes: Array<string>;
    username: string;
    password: string;
};

export { ValidCacheType }

// @public (undocumented)
export const version = "2.15.0";

// Warnings were encountered during analysis:
//
// src/index.ts:8:12 - (tsdoc-characters-after-block-tag) The token "@azure" looks like a TSDoc tag but contains an invalid character "/"; if it is not a tag, use a backslash to escape the "@"
// src/index.ts:8:4 - (tsdoc-undefined-tag) The TSDoc tag "@module" is not defined in this configuration

```
